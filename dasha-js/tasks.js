function task1() {
  // Калькулятор на while true

  while (true) { // бесконечный цикл, успользуется вместе с break под условием
    let a = +prompt('a:'), // запрашиваем А, + перед prompt преобразовывает в число https://learn.javascript.ru/operators#privedenie-k-chislu-unarnyy
      b = +prompt('b:'), // запрашиваем В и преобразовываем строку в число
      oper = prompt('oper:'), // запрашиваем оператор
      res; // заводим переменную для результата

    // исходя из оператора выбираем что положить в результат
    if (oper == '+') res = a + b; // сложение
    else if (oper == '-') res = a - b; // вычитание
    else if (oper == '*') res = a * b; // умножение
    else if (oper == '/') res = a / b; // деление

    // теперь в результате сумма, разность, умножение или деление
    alert('Результат: ' + res); // выводим результат

    // спрашиваем надо ли считать ещё раз
    let again = prompt('Хотите вычислить снова?');
    if (again != 'да') break; // если пользователь ответил "да", то считаем ещё раз
    // если пользователь ответит, что-то другое, например "ДА" (большие буквы) или ничего не ответит
    // то цикл прекратится, и мы выйдем из функции
  }
}

function task2() {
  // Поиск максимального элемента в массиве

  // сперва зададим массив чисел
  let arr = [1, 3, 4, 2, 65, -77, 4, 3, 32];

  // в качестве базового максимального элемента возьмем первый элемент
  let max = arr[0];
  for (let el of arr) // перебираем каждый элемент массива
    if (max < el) max = el; // если попался элемент больше текущего, то переопределяем макс на этот элемент

  console.log(arr); // выводим массив в консоль
  console.log('max:', max); // и сам максимальный элемент
}

function task3() {
  // Разбиение строки на слова

  // простой промпт обёрнутый в функцию, возвращается строка - то что ввел пользователь
  function getSentense() { return prompt('Введите предложение:'); }

  // функция получает один аргумент - предложение которое ввел пользователь
  function splitSentense(sentense) {
    let words = [], // массив в который мы будем складывать все слова
      word = ''; // строка для сбора символов текущего слова

    for (let char of sentense) { // перебираем каждый символ предложения
      if (char != ' ') word += char; // если символ не является пробелом добавляем его к текущему слову
      else { words.push(word); word = ''; } // если же пробел, то слово собрано, кладем его в массив со словами и обнуляем переменную с текущим словом
      // push является базовым методом массива в js - https://learn.javascript.ru/array-methods
    }
    words.push(word); // в конце останется одно слово, которое тоже надо положить в результат

    return words; // возвращаем массив слов в место вызова функции
  }

  while (true) { // while true для возможности ввести несколько предложений
    // вызовы происходят в следйющем порядке
    // 1. getSentense
    // 2. splitSentense(значение возвращенное из getSentense)
    // 3. console.log(массив возвращенный из splitSentense)
    console.log(splitSentense(getSentense()));
    // если пользователь введет "да", то while true повторит всё с начала
    if (prompt('Разбить на слова снова?') != 'да') break; // иначе выходим из цикла
  }
}

function task4() {
  // Получение индекса элемента в массиве (поиск элемента)

  // функция принимает два аргумента - массив и целевой элемент
  function findIndex(arr, target) {
    for (let i = 0; i < arr.length; i++) // перебираем каждый элемент массива
      if (target === arr[i]) // если мы нашли целевой элемент
        return i; // возвращаем его индекс
  }

  //         0  1  2  3     4       5;
  let arr = [1, 3, 2, 7, 'Hello', true];

  // ниже представлены варианты вызова функций
  findIndex(arr, 1); // 0
  findIndex(arr, true); // 5
  findIndex(arr, 'Hello'); // 4
}

function task5() {
  // Фильтрация массива
  // Под фильтрацией подразумевается отсеивание элементов массива не удовлетворяющих задаваемому условию
  // Условие задаётся с помощью коллбэка, настаиваю на стрелочных функциях, поскльку это современный и очень удобный стандарт языка
  // Литература:
  // 1) Function Expression (Анонимные функции) - https://learn.javascript.ru/function-expressions
  // 2) Arrow Function (Стрелочные функции) - https://learn.javascript.ru/arrow-functions-basics

  // Функция принимает два аргемнта - массив для фильтрации и коллбэк задающий условие отсеивания
  // Если коллбэк будет возвращать true, то этот элемент оставляем, в противном случае - отсеиваем
  function filter(arr, callback) {
    let result = []; // создаем массив в который будем складывать подходящие элементы

    for (let el of arr) // перебираем каждый элемент массива
      if (callback(el)) // отправляем элемент на проверку в коллбэк
        result.push(el); // если коллбэк вернул true (т.е.  проврка пройдена успешно) записываем элемент в результат

    return result; // возвращаем результат работы функции
  }

  // пример работы функции будет показан на двух разных массивах
  let nums = [1, 2, 4, 2, 1, 5, 3, 5, 7, 8, 4, 9]; // массив чисел
  let any = ['Hello', 10, true, false, [1, 2, 3], 'FTI']; // массив разных элементов

  // выбираем числа меньше 5
  let numsLess5 = filter(nums, el => el < 5); // [1, 2, 4, 2, 1, 3, 4]
  // выбираем числа больше 5 
  let numsMore5 = filter(nums, el => el > 5); // [7, 8, 9]

  // выбираем только строки
  let anyJustStrings = filter(any, el => typeof el == 'string'); // ['Hello', 'FTI']
  // выбираем только логический тип
  let anyJustBoolean = filter(any, el => typeof el == 'boolean'); // [true, false]

  console.log(numsLess5, numsMore5); // выводим новые массивы на базе nums
  console.log(anyJustStrings, anyJustBoolean); // выводим новые массивы на базе any
}

function task6() {
  // Регистрация пользователей в localStorage

  // СПРАВКА
  //
  // localStorage - это внутреннее хранилище браузера. В него можно сохранить какие-то данные.
  // Для работы с localStorage есть два основных метода:
  // 1) localStorage.getItem(ключ_строка)
  // 2) localStorage.setItem(ключ_строка, значение_строка)
  // Литература: https://learn.javascript.ru/localstorage
  //
  // JSON - строковый формат данных впервые появившийся в JavaScript. Сейчас очень широко используется.
  // Представляет из себя иерархию в формате ключ: значение - что является простым объектом в JavaScript.
  // Простые объекты (Plain Objects) в JavaScript - https://learn.javascript.ru/object
  // Такие объекты могут быть записаны в качестве строк. 
  // Объекты записанные в качестве строк могут быть преобразованы назад в "живой" объект.
  // Для этого в JavaScript есть специальный набор методов:
  // 1) JSON.stringify(объект_для_превращения_в_строку) - создаёт строку на базе объекта
  // 2) JSON.parse(строка_для_превращения_в_живой_объект) - создаёт объект на базе строки
  // Литература: https://learn.javascript.ru/json
  //
  // Спец фичи JavaScript операторов || и && (логич ИЛИ, логич И)
  // Дело в том что в JavaScript эти операторы обладают прекрасным свойством возвращать не просто
  // true или false, а само значение которое является истиной или ложью в рамках языка
  // Подробнее тут: https://learn.javascript.ru/logical-operators
  //
  // Тернарный оператор - как однострочное условие
  // Этот оператор представляет из себя сокращенную запись условия и возвращает одно из значений.
  // Достаточно часто применяется на практике!!!
  // Синтаксис: условие ? если_ДА : если_НЕТ
  // // На месте если_ДА и если_НЕТ могжет стоять только одно дейтсвие или значение.
  // Преобразование if else в тернарный оператор:
  // --------------------- IF ELSE
  // let a = 5, res;
  // if (a < 10) res = 'Hello';
  // else res = 'World';
  // console.log(res); // 'Hello'
  // --------------------- Тернарный оператор
  // let a = 5;
  // let res = a < 5 ? 'Hello' : 'World';
  // console.log(res); // 'Hello'
  // Подробнее тут: https://learn.javascript.ru/ifelse#uslovnyy-operator

  // образаемся в localStorage и берём от туда юзеров
  // если человек зашел на сайт первый раз, то никаких юзеров не будет, следовательно localUsers == undefined
  let localUsers = localStorage.getItem('users');
  // если в localStorage что-то было, то создаем на базе той строки объект и кладем в переменную users
  // иначе в качестве users у нас будет пустой массив (эта ситуация если пользователь первый раз на сайте)
  let users = localUsers ? JSON.parse(localUsers) : [];

  // Спрашиваем что хочет пользователь
  let mode = +prompt(`Что вы хотите сделать? (1 или 2)
  1. Зарегистрироваться;
  2. Просмотреть всех пользователей.`);
  if (mode == 1) // если пользователь хочет зарегистрироваться
    register(); // вызываем функцию регистрации
  else // 2 - если хочет посмотреть всех пользователей
    showUsers(); // вызываем функцию показывания всех пользователей

  // функция регистрации не принимает никаких параметров, она будет использовать переменную users,
  // которая была объявлено глобально относительно места опеределния функции (https://learn.javascript.ru/closure)
  // рекоменду не заморачиваться на этой теме сейчас, она достаточно сложная для новичка, а без неё ты сможешь прожить
  // лучше посмотри короткий видосик на область видимости переменных в JS - https://youtu.be/3UXqvjmJkA0
  function register() {
    // эта функция создает объект пользователя
    let user = {
      name: prompt('Ваше имя:'), // в свойство name кладётся то что введёт пользователь на промпт имени
      surname: prompt('Фамилия:'),  // в свойство surname кладётся то что введёт пользователь на промпт фамилии
      age: prompt('Сколько вам лет:'), // в свойство age кладётся то что введёт пользователь на промпт возраста
    };
    // строки выполняются последовательно, так что свойства объекта заполнятся в таком же порядке как они указаны
    // и будет 3 промпта

    // когда объект юзера заполнен кладем его в массив всех юзеров
    users.push(user);
    // теперь сохраняем объект всех юзеров в локальное хранилище браузера
    localStorage.setItem('users', JSON.stringify(users)); // для этого создаём строку на базе объекта (массива) users
  }

  // эта функция также использует users из глобальной области видимости
  function showUsers() {
    // она создаёт строку, в которой находится информация о всех пользователях
    let usersString = ''; // изначально она пуста
    // далее мы будем её наращивать через +=

    for (let user of users) // перебираем каждого пользователя
      usersString +=                                                       // --\
        ` > ${user.name.toUpperCase()} ${user.surname} [${user.age}] \n`;  //   /
    // тут использована специальная строка с косыми кавычками,               <<
    // это называется интерполяция строк, и ПОСТОЯННО используется на практике.
    // Это удобный вариант записи конкатенации (сложения) строк.
    // Подробнее тут: https://learn.javascript.ru/string#kavychki

    alert(usersString); // выводим всех пользователей
  }
}

function task7() {
  // СПЕЦ ЗАДАНИЕ - не рекомендовано к рассмотрению
  // Оно тренирует алгоритмическое мышление, но нам и без этого можно сейчас обойтись

  // Сортировка массива чисел вставками

  // Есть множество сортировок массивов, каждая из них хороша по своему
  // В современной практике такие функции никто не пишет, поскольку все эти
  // алгоритмы реализованы и записаны во встроенном методе массива arr.sort(...)
  // https://learn.javascript.ru/array-methods#sort-fn
  //
  // Однако, эти алгоримты очень круто прокачивают алгоритмическое мышление,
  // поэтому до сих пор их каждый год пишут в уч заведениях. Мы должны
  // писать эти алгоритмы на СиАОД.
  //
  // Сортировка вставками мне нравится больше всего, поскольку она очень элегантна.
  // Рекомендую посмотреть видео по тому как она работает, потому что код в лоб
  // разбирать не реально - https://youtu.be/ZxpcEQcqHWU

  let arr = [1, 2, 3, 33, 12, -44, 13, 75, 57, 93, 12, 43, -34, -56];
  console.log('insertionSort');
  console.log(arr);
  insertionSort(arr);
  console.log(arr);

  function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++)
      for (let j = i; j > 0 && arr[j - 1] > arr[j]; j--) // пока j>0 и элемент j-1 > j, arr-массив
        [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]; // меняем местами элементы j и j-1
    // на строке выше использовано нововведение языка - деструктивное присваивание
    // подробнее об этом тут - https://learn.javascript.ru/destructuring-assignment
  }
}

function task8() {
  // СПЕЦ ЗАДАНИЕ - не рекомендовано к рассмотрению
  // Оно тренирует алгоритмическое мышление, но нам и без этого можно сейчас обойтись

  // Быстрая сортировка

  // Быстрая сортировка не зря называется быстрой. Она считается самой быстрой на сегодняшний день
  // В ОБЩЕМ СЛУЧАЕ массивов. Встречаются массивы в которых она не самая быстрая.
  // Она использует рекурсию, в своей работе и достаточно сложна для понимания работы, пока есть проблемы
  // с пониманием рекурсии.
  // Логика быстрой сортировки тут - https://youtu.be/Xgaj0Vxz_to
  // Чувак говорит про сложность алгоритма (N^2 и N*logN), я это понял далеко не сразу,
  // так что можешь скипнуть на начале абсолютно спокойно.

  // Создаём массив
  let arr = [1, 2, 3, 33, 12, -44, 13, 75, 57, 93, 12, 43, -34, -56];
  console.log('quickSort'); // выводим сообщение о методе сортировки
  console.log(arr); // выводим сам массив
  quickSort(arr); // сортируем
  console.log(arr); // выводим снова

  function pivot(arr, start = 0, end = arr.length + 1) { // разделение по пивоту (смотри видосик)
    const swap = (list, a, b) => [list[a], list[b]] = [list[b], list[a]]; // деструктурирующее присваивание + стрелочная функция

    // создаем пивот и указатель, в качестве пивота первый элемент массива
    let pivot = arr[start],
      pointer = start;

    // бежим по массиву
    for (let i = start; i < arr.length; i++) {
      if (arr[i] < pivot) {
        pointer++;
        swap(arr, pointer, i); // шагаем поинтером и i, свапаем когда надо
      }
    };
    swap(arr, start, pointer); // в конце тоже свапаем последний элемент

    return pointer; // возвращаем место пивота
  }

  // сама функция быстрой сортировки использует функцию pivot и работает рекурсивно
  function quickSort(arr, start = 0, end = arr.length) {
    // сперва пивотим массив, т.е. делим на большие и маленькие элементы
    let pivotIndex = pivot(arr, start, end);

    if (start >= end) return arr;
    // далее рекурсия - обрабатываем большие и маленькие элементы
    quickSort(arr, start, pivotIndex); // маленькие
    quickSort(arr, pivotIndex + 1, end); // большие

    return arr; // возвращаем отсортированный массив
  }
}

// главная функция, в которой вызываются все остальные
function main() {
  // тут можно комментировать лишние функции, например оставить только task6
  alert('Часть информации выводится в консоль, нажми Ctrl+Shift+I или F12');

  task1();
  task2();
  task3();
  task4();
  task5();
  task6();
  task7(); // FIXME: это спец задание, можно не разбирать
  task8(); // FIXME: это спец задание, можно не разбирать
}

// вызов главной функции - входная точка в программу
main();